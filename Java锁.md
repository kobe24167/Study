#  Java 中的锁

##  synchronized的四种用法：
  * 修饰方法synchronized void method()
  * 修饰一个代码块synchronized(this) 指定要给某个对象加锁synchronized (object) {}
  * 修饰一个静态的方法synchronized static void method() {}
  * 修饰一个类synchronized(ClassName.class) {}
[自己写的例子](https://github.com/kobe24167/Study/blob/master/test/src/com/aa/test/LockerTester.java)

## volatile
  * 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
  * 禁止进行指令重排序，能在一定程度上保证有序性。
  * 不能保证原子性
  * 使用volatile必须具备以下2个条件
	1）对变量的写操作不依赖于当前值
　　2）该变量没有包含在具有其他变量的不变式中


## 在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题
## 乐观锁
乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。

## 悲观锁
悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。
  
## 锁优化
减少锁的时间，减少锁的粒度